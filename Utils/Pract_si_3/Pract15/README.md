# Задачи

### 1. Дървовидни структури

**Задача 1.1** Трябва да се създаде **калкулатор за множества** `SetCalculator`. По подаден `String` в конструктура на калкулатора, той трябва да може да го parse-не (да извлече данните за израз с множества `SetExpression`) и след това да проверява дали подаден елемент е в множеството.

Класът `SetExpression` е абстрактен базов клас за дървовидна структура. Той съдържа pure virtual функция `bool isElementIn(const Element& el)`, която ще отговаря за това дали даден елемент е вътре в класа. `Element` е вложена структура в класа `SetExpression`, която има следният вид:

```c++
	struct Element
	{
		bool sets[26] = { false };

		void set(char ch, bool isIn)
		{
			assert(ch >= 'A' && ch <= 'Z');
			sets[ch - 'A'] = isIn;
		}
		bool get(char ch) const
		{
			assert(ch >= 'A' && ch <= 'Z');
			return sets[ch - 'A'];
		}
	};
```

Конкретни наследници на `SetExpression` са `Singleton`, `UnaryOperation` и `BinaryOperation`.
* `Singleton` - приема символ в конструктура. Функцията `.isElementIn` извиква `.get` върху подаденият обект от тип `Element`.
  
* `UnaryOperation` - приема един символ и един указател от тип `SetExpression`. Ако символът е '!', `.isElementIn` извиква връща негацията на резултата от `.isElementIn` на композирания обект върху подадения елемент. В противен случай функцията връща `false`.
  
* `BinaryOperation` - приема един символ и два указателя от тип `SetExpression`. Символите, които трябва да се поддържат са съответно 'v' - дизюнкция, '^' - конюнкция, '\\' - разлика, 'x' - симетрична разлика.

Вашият калкулатор трябва да може да изгради дърво от изрази на база подаденият String. След това чрез функция `bool isElementIn(const Element& el)` да проверява дали елементът се съдръжа в дървото. 

**Задача 1.2** Трябва да създадете дървовидна структура от множества. Тя се състои от следните класове: 
   * `Set` - базов абстрактен клас, представляващ множество. Има pure virtual функция `bool accepts(unsigned int)`, която ще определя дали даден елемент е в множеството или не.
   * `SetByCriteria<T>` - темплейтен наследник на `Set`, който пази в себе си обект от шаблонен тип `Т`. За този обект ще бъде подаван указател към функция или обект, държащ се като функция. Композираният обект ще ви се подава в конструктура (трябва да може да се приеме чрез копиране или чрез местене). Функцията `accept()` връща резултата от извикване на `operator()` от обекта `T` върху подаденото входно число.
   * `SetOperation` - абстрактен наследник на `Set`, който представлява контейнер за други `Set`-ове. Има разписана само Big6 в себе си, а член-данните му са protected.
   * `UnionOfSets` - наследник на `SetOperation`, който в конструктура приема масив от указатели към други множества и ги запазва в себе си (чрез копиране или move). Предефинира функцията `accept()`, като я извиква на елементите в себе си, а резултатът е конюнкция от резултатите.
   * `IntersectionOfSets` - наследник на `SetOperation`, който в конструктура приема масив от указатели към други множества и ги запазва в себе си (чрез копиране или move). Предефинира функцията `accept()`, като я извиква на елементите в себе си, а резултатът е дизюнкция от резултатите.

Създайте няколко обекта, държащи се като функции, както и factory, създаващо множества на база данните от файл (подобно на Домашно 3).

**Задача 1.3** Реализирайте дървовидна структура, която представя йерархията в една софтеурна компания. Има 2 вида работници: обикновен работник, който има име и заплата, както и мениджър, който освен това има име на позицията ("Manager", "CEO" и т.н.) и пази работниците и мениджърите, които ръководи. На върха на йерархията седи CEO.

Да се напшат следните функции:
- `addSubordinate(Employee* subordinate)`, която може да се извика само мърху мениджър и добавя подчинен на мениджъра
- `print()`, която, ако е извикана мърху мениджър, принтира себе си и своите подчинени, а ако е извикана върху обкновен работник, принтира само работника
- `getWorkersCount()`, която връща броят на подчинените, които ръководи посоченият работник. Обикновените служители не ръководят никого (функцията връща `0`).

```c++
- CEO 
	- Manager 1 
		- Employee 1 
		- Employee 2 
	- Manager 2
		- Employee 3
```

### 2. Design Patterns

**Задача 2.1** Да се реализира функция `binarySearch`, която връща итератор към намерения елемент.

**Задача 2.2** Да се реализира онлайн система за купуване и продаване на различни електронни устройства. Към момента системата поддържа:
- настолни компютри, които имат модел (стринг) и цена 
- лаптопи, които имат модел (стринг), цена и тегло
- мишки, които имат модел (стринг), цена и DPI
-  клавиатури, които имат модел (стринг), цена и layout

Онлайн магазинът трябва да поддържа следните функционалности:
- да продава даден продукт, т.е. да го маха от склада и го прибавя в количката на подадения потребител
- да купува продукт, т.е. да го добавя в склада
- да итерира през продутктите в склада

Използвайте подходящи design pattern-и.

Подсказки:
- използвайте Factory Pattern за създаване на различните продукти
- използвайте Command Pattern за логиката на купуването и продаването
- използвайте Singleton за инвентара
- използвайте Iterator за итериране през продуктите в склада
