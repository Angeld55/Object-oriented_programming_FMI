# Kindle

## Помощни средства които използвахме
За решението на тази задача използваме клас string, клас vector и клас pair. String е взет директно от семинарите на първа група, с добавена функция getLine(), която използваме подобно на std::getline();
Вектора е взет от семинарите на втора група.
Класът Pair е единствено с цел улеснение. Той представлява наредена двойка от два темплейтни типа.
Всяко едно нещо което сме направили с тези помощни средства може да се направи и без тях - просто кодът става по - дълъг.

## Използване на командите
### Команди, които поддържаме преди да се логне потребител:
* login - влизаме в системата
* signup - регистрираме се в системата
* view - преглеждаме какви книги имаме
* save - запазваме текущия Kindle във файл
* load - зареждаме Kindle от файл
* exit - излизаме от системата 
### Команди, които има потребител:
* read - прочита книга
* write - пише книга
* rate - оценява книга
* comment - коментира под книга
* rates - проверява рейтинга на книгата
* comments - проверява коментарите под книгата
* view - преглежда какви книги има
* exit - излиза от профила си
### Команди които имаме докато четем книга:
* n - следваща страница
* p - предишна страница
* @ + [number] - отива на страница, която е подадена
* h - показва/скрива help меню
* q - излиза от режим на четене

Въвеждаме команда и натискаме Enter. След това програмата ни пита ако има нужда от допълнителна информация. Пример
```
> login
> Enter user name: [Name]
> Enter user password: [Password]
> Success!
>
```

## Накратко за запазването във файлове
Имаме да запазваме сложна структура във файл. Това което можем да направим е да я разбием на по - прости. В Kindle имаме два вектора, които представляват книгите и потребителите. Ако измислим метод да запазим книга и потребител другото е лесно. Можете да видите, че в класовете представляващи книга и потребител имаме отделни функции, които се грижат за работата със запазването.
Логиката за тях е аналогична - разбиваме структурата на по - малки структурки, които стават все по - лесни и по - лесни за запазване.

## Допълнителни бележки
В решението сме използвали friend класове. Това не винаги е лоша идея, но внимавайте с тях - възможно е да доведат до логически грешки, тоест на един клас да се дадат твърде много права над друг.

При запазването на класа ще видите следния код
```cpp
outFile.write("#Ty", 4);
```
При четенето на класа ще видите следния код
```cpp
char typeChecker[4];
inFile.read(typeChecker, 4);
if (strcmp(typeChecker, "#Ty") != 0) {
	std::cout << "Invalid file type" << std::endl;
	return;
}
```
Реално, няма как да гарантираме, че подадения файл ни е коректен. Потребителя винаги може да подаде некоректен файл, което може да счупи нашата система. За това правим следното: в началото на файла, който запазваме, записваме някаква последователност от n символа. Когато четем, прочитаме първите n (в случая 4) байта от файла и казваме - ако това е "тайният" низ, то значи този файл е писан от системата, тоест се очаква да е коректен. В противен случай приключваме изпълнението и не четем излишни данни, които могат да счупят системата ни.

Също така, функционалността за промяна на книга оставяме на Вас. Чувствайте се свободни да експериментирате и pull-request вате.

<b>При каквито и да е въпроси екипът по ООП е на линия.</b>